# [CS STUDY] 1. JAVA

---

# **1) 객체 지향 프로그래밍**

**JAVA는 객체 지향 프로그래밍 언어**이다.

**객체**란, 독립된 채 속성과 기능을 가지는 프로그램 단위를 의미한다.

**객체 지향 프로그래밍**이란, 프로그램을 이러한 **객체들의 연계**로써 구현하는 것을 뜻한다.

 

## (A) 4가지 특징

- **추상화**
    
    객체에서 불필요한 부분을 제거하고, 공통된 부분을 추출하여 표현하는 것을 의미한다.
    
    가령, 다양한 종의 동물들을 ‘동물’이라는 추상적인 객체로 묶는 것을 의미한다.
    
- **상속**
    
    공통된 특성을 가지는 상위 클래스로부터, 여러 개의 **하위 클래스가 상위 클래스의 속성과 기능을 사용할 수 있도록 하는 것**을 의미한다.
    
    이를 통해 코드의 **재사용성을 높인다.**
    
- **다형성**
    
    객체의 속성이나 기능이 **상황에 따라 여러 형태를 가질 수 있는 것**을 의미한다.
    
    오버로딩 ( Overloading ) : 매개 변수의 유형과 개수가 다른 같은 이름의 여러 메서드를 가지는 것
    
    오버라이딩 ( Overriding ) : 상위 클래스가 가지고 있는 메서드를 하위 클래스에서 재정의하여 사용하는 것.
    
- **캡슐화**
    
    **연관이 있는 속성과 기능들을 하나로 묶어, 외부로부터 데이터를 보호하는 것**이다.
    
    보호 : 기능을 외부에서 수정할 수 없도록 한다.
    
    은닉 : 기능의 세부 동작을 외부에서 열람할 수 없도록 한다.
    

## (B) SOLID 5원칙

- **SRP**
    
    **단일 책임 원칙** (Single responsibility principle)
    **한 클래스는 하나의 책임**만 가져야 한다.
    
- **OCP**
    
    **개방-폐쇄 원칙** (Open/closed principle)
    소프트웨어 요소는 **확장에는 열려 있으나 변경에는 닫혀 있어야** 한다.
    
- **LSP**
    
    **리스코프 치환 원칙** (Liskov substitution principle)
    프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 **하위 타입의 인스턴스로 바꿀 수 있어야 한다.**
    
- **ISP**
    
    **인터페이스 분리 원칙** (Interface segregation principle)
    특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
    
- **DIP**
    
    **의존관계 역전 원칙** (Dependency inversion principle)
    프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.
    

---

# 2) JAVA의 메모리 관리

**JAVA**는 유저가 직접 메모리를 관리하는 것을 권장하지 않으며, **JVM(자바 가상 머신)가 가비지 컬렉션( Garbag Collection )을 통해 메모리를 관리**한다.

## (A) 데이터 타입

- **기본 타입(Primitive Type)**
    - **boolean, byte, short, int, long, float, double, char**의 8가지 자료형을 의미한다.
    - **스택 영역에 실제 값을 저장**한다.

- **참조 타입(Reference Type)**
    - **기본 타입을 제외한 모든 타입**을 의미한다. (빈 객체 NULL 포함)
    - **실제 값은 Heap 영역에 저장**한다.
    - **실제 값이 저장된 힙 영역의 주소값(해시)을 스택 영역에 저장**한다.

## (B) 메모리 영역

- **메소드(Method) 영역**
    - **클래스 파일의 바이트 코드가 올라오는 영역**으로서, 런타임 중에 해당 클래스가 호출되면 **동적으로 메모리에 탑재된다**.

- **힙(Heap) 영역**
    - **생성된 객체의 인스턴스가 저장되는 영역**이다.

- **스택(Stack) 영역**
    - 메서드의 **기본 타입의 실제 값**과 **참조 타입 자료형의 주소값**이 저장되는 영역이다.
    - **스레드 하나당 하나씩 가지고 있는 영역**으로, 다른 스레드의 스택에 접근할 수 없다.
    - **스택 구조를 이용하여 하위 변수에만 접근**할 수 있으며, **메서드가 종료되면 스택에서 메모리가 해제**된다.

## (C) 가비지 컬렉션 ( GC )

**객체의 인스턴스가 존재하는 힙 영역에 대하여 관리가 진행된다.**

- **동작 순서**
    
    1) **Stop The World 단계** : JVM이 모든 쓰레드를 멈추는 단계
    
    2) **Mark and Sweep 단계** : Mark(비사용 메모리 식별)과 Sweep(비사용 메모리 해제)를 진행하는 단계
    
- **영역**
    - **Young 영역**
        - **Eden** : 최초 생성된 객체가 위치하는 영역
        - **Survivor** : 최소 1번의 GC에서 살아남은 객체의 영역
            
            ↳ Survivor 영역은 2개가 있으며, 항상 다른 하나는 비워 두었다가 살아남은 객체를 이전한다.
            
    - **Old 영역**
        - **오래 살아남았거나, Young 영역에 둘 수 없을 만큼 큰 객체를 저장**한다.
        - **공간 할당을 Young 영역보다 크게 한다.**

- **GC 실행**
    - **minor GC**
        - **Young 영역의 공간이 부족한 경우 발생하며, Young 영역에서 사용하지 않는 객체를 해제**한다.
        - 영역이 작고 **빠르다**.
    - **major GC**
        - **Old 영역의 공간이 부족한 경우 발생하며, Old 영역에서 사용하지 않는 객체들을 해제**한다.
        - 영역이 크고 **느리다**.

---

# 3) JAVA의 컴파일 & 실행

## (A) 절차

- **자바 컴파일러 (javac)에 의한 컴파일**
    - **JDK(Java Development Kit)**에 탑재된 **자바 컴파일러(javac)가 원본 소스파일인 .java 코드를 .class 자바 바이트 코드로 컴파일**한다.
    - 이 때, **원본 소스 파일의 변경이 감지되지 않은 경우에는 class 파일을 재활용**한다.
    - 
- **자바 가상머신(JVM)에 의한 실행(런타임)**
    - **class 파일을 읽어 OS에 맞추어 실행한다.**
    - JVM는 필수 라이브러리들을 필요로 하며, **JRE(Java Runtime Environment)는 필수 라이브러리와 JVM를 함께 제공**한다.

## (B) 이식성

**JAVA는 가상 머신 위에서 실행되기 때문에, 컴파일 이후에도 OS의 영향을 받지 않는다.**

**따라서 이식성이 높다.**

- **vs C언어**
    - C언어의 경우 기계어로 즉시 컴파일하기 때문에, **컴파일 이후 OS의 영향**을 받는다. **따라서 이식성이 낮다**

(ex. 윈도우의 exe파일의 경우 맥에서 실행되지 않는다. ) 

- **vs Python**
    - 자바의 **.class와 유사하게 .pyc 형태의 byte 코드로 컴파일을 진행**하며, 이를 **파이썬 가상 머신에서 실행**한다.
    - **JAVA와 동일하게 이식성이 높다.**
